# ACS Evolution

*Code written 2022-2026 | Documentation created February 2025 with Claude AI assistance*

---

## Overview

This directory documents the evolution of the Alternative Medical Symbol (AMS) preset system's ACS scripting from simple getter functions (2022) through multiple failed attempts at preset/custom mode coexistence (October 2022) to a unified, scalable architecture (2025-2026).

The progression shows a self-taught learning journey: from not understanding flow control or script execution models, to implementing sophisticated state management patterns and data-driven architectures.

---

## The Core Challenge

**Goal:** Allow users to choose between preset modes (all items match) and custom mode (each item independent), with the ability to change presets even in custom mode (override/quick-set behavior).

**Why this was hard:**
- Managing multiple CVars (medtoggle, stmtoggle, brztoggle) based on master state
- Detecting when preset changes vs when individual items change
- Understanding ACS execution models (when scripts run, how to loop)
- Flow control fundamentals (nested conditions, unreachable code)

---

## Development Timeline

**August-September 2022:** v0 getters (simple, working)

**October 17-20, 2022:** v1 attempts (replacing buttons with dropdowns)

**October 24, 2022:** INTENSE experimentation - v2 and v3 attempts in parallel

**October 25-26, 2022:** Continued v2 refinements

**October 27, 2022:** v3-alpha BREAKTHROUGH - router + worker pattern succeeds

**December 30, 2025:** v4 consolidation, v5 unified worker (with AI assistance)

**January 2026:** v5 refinements and ZScript integration

---

## Architecture Evolution

### v0: Simple Getters (September 2022)
**File:** `v0-getters.acs`

Three tiny scripts that return CVar values to DECORATE actors:
```c
script "MEDOptions" (void)
{
    SetResultValue(GetUserCVar(0, "medtoggle"));
}
What it does: DECORATE calls these every frame to check which sprite to display
What it taught: Basic ACS structure, how DECORATE interacts with scripts
v1: Preset Attempts (October 17-20, 2022)
Folder: v1-preset-attempts/
Goal: Replace v0's working KEYCONF buttons with dropdown menus for visual consistency.
Contains:
v1-failed-attempt1/ - "Smart getters" that check mode (sound logic, unclear why failed)
v1-failed-attempt2/ - Central script with duplicate conditions (flow control problems)
v1-successful/ - Working preset/custom separation (preserved in v2 comments)
What worked: v1-successful achieved preset + custom modes with compound conditions
Limitation: No overlap - changing preset in custom mode did nothing (lost v0 button behavior)
What it taught:
Compound conditions (Preset==0 && Master==0)
Variables for readability
GetUserCVar vs GetCVar distinction
That working code can still be limited
v2: Experimental Overlap Attempts (October 24-26, 2022)
Folder: v2-experimental/
Goal: Restore v0's button override behavior - make preset dropdown work in custom mode
October 24 (intense day):
Multiple parallel approaches tried
v2a iteration 1: First attempt
(v3 attempts also started this day - see v3-attempts/)
October 25-26:
v2a iterations 2-3: Different logic approaches
October 26 final (iteration 4):
Dual-script system (SYMPreset + SYMCustomPreset)
Added Delay + Restart loop (learning!)
Preset mode works, custom mode has broken nested logic
What didn't work: Nested conditions checking Preset==1 inside Preset==0 blocks (unreachable code)
What it taught:
Flow control pitfalls
Importance of testing conditions
That complexity doesn't mean correctness
Loop structure (Delay + Restart)
v3: Failed Consolidation (October 24, 2022)
Folder: v3-attempts/
Same day as v2 experiments - trying multiple approaches in parallel:
v3/ - Consolidation attempt
v3b/ - Refinement
v3b1/ - Further refinement
v3a-oct24-attempt1/ - Early v3a exploration
v3a-oct24-attempt2/ - Second attempt same day
All failed - but the exploration was building toward the breakthrough
What it taught: Sometimes you need to try EVERYTHING to find what works
v3-alpha: BREAKTHROUGH (October 27, 2022) ✨
Folder: v3-alpha-breakthrough/
The router + worker pattern that finally worked!
Architecture:
SYMPreset (Router):
- Runs continuously (Delay + Restart loop)
- Checks pretoggle value
- Calls appropriate worker script

SYMRed/Green/Pills (Workers):
- Each handles one preset value
- Checks Master toggle (asmtoggle)
- Preset mode: Sets all CVars to preset
- Custom mode with same preset: SetResultValue (do nothing)
- Custom mode with different preset: Set CVars (quick-set!)
Why this works:
Separation of concerns (routing vs logic)
Each worker focused on one preset
State checking allows overlap behavior
Clean, understandable structure
After 10 days of iteration (Oct 17-27), preset/custom overlap finally achieved!
What it taught:
Architectural patterns matter
Separation of concerns
That the breakthrough often comes after exhaustive exploration
v4: Consolidated Logic (December 30, 2025)
Folder: v4-consolidated/
After 3 years dormant, returned to project
v4a - Actual Implementation:
Refined v3-alpha's worker pattern:
// v3-alpha checked each "other preset" explicitly:
Else If(Preset == 1 && Master == 1) { Set to 1 }
Else If(Preset == 2 && Master == 1) { Set to 2 }

// v4 consolidated:
Else If(Preset != 0 && Master == 1) { 
    Set CVars to Preset value directly
}
Benefit: Adding new presets only requires != X check, not hardcoding all other values
Status: Verified functional but never actively used - v5 completed minutes later
v4b - Optimization Concept:
Move Delay+Restart from router to workers - router only executes when preset changes
Status: Conceptual, never implemented or tested - "road not taken"
What it taught:
DRY principle (Don't Repeat Yourself)
Data-driven vs hardcoded approaches
That optimization ideas can be valuable even if not pursued
v5: Unified Worker (December 30, 2025 - January 2026)
Folder: v5-unified-worker/
Complete architectural refactor with Microsoft Copilot assistance
The Innovation: Single script with state memory
int LastPreset = -1;  // Global variable tracks previous state

script "SYMWorker" (void)
{
    // Initialize on first run
    if (LastPreset == -1) LastPreset = Preset;
    
    // Preset mode: Set all CVars
    if (Master == 0) { ... }
    
    // Custom mode, preset unchanged: Do nothing
    else if (Master == 1 && Preset == LastPreset) { ... }
    
    // Custom mode, preset changed: Quick-set
    else if (Master == 1 && Preset != LastPreset) { ... }
    
    // Update memory
    LastPreset = Preset;
}
Why this is elegant:
No hardcoded worker scripts per preset
Fully scalable (works for unlimited presets)
State memory pattern (tracks changes over time)
Data-driven architecture
Development process:
Copilot generated initial architecture (arrays, detection logic)
Debugged through conversation (mental/logical analysis, no execution)
Identified initialization bug (first-load would override custom setups)
Removed unnecessary arrays (preset value IS the value!)
Added getter scripts back for DECORATE integration
5-6 iterations from concept to working code, under 1 hour total
Collaboration approach:
I provided architectural requirements based on v4's limitations
Copilot generated code, I debugged mentally and guided refinements
Final optimizations (array removal, structure) done independently
What it taught:
AI can accelerate architecture exploration
Debugging by reasoning (not just running code)
That "simple" solutions emerge after understanding complexity
Modern development workflows
Future refinements (planned):
Indexed getter pattern (inspired by v6 ZScript concept)
Consolidate 3 getters into single parameterized script
Backporting modern patterns to stable architecture
Key Learning Moments
Flow Control (v1-v2):
Duplicate conditions create unreachable code
Nested conditions must be logically possible
SetResultValue only returns one value (not three)
Script Execution (v1-v2):
Scripts need entry points (OPEN, ENTER, or explicit calls)
Delay + Restart creates continuous loop
When to use loops vs per-frame calls
Architecture (v3-alpha breakthrough):
Separation of concerns (router vs workers)
Each component has one responsibility
Clean boundaries make debugging easier
Scalability (v4-v5):
DRY principle reduces duplication
Data-driven beats hardcoded
State memory enables sophisticated behavior
Modern Development (v5):
AI assistance accelerates exploration
Mental debugging develops deep understanding
Iteration and refinement never stops
Code Commenting Status
Fully commented:
v0-getters.acs ✅
v1-failed-attempt1 ✅
v1-failed-attempt2 ✅
v1-successful ✅
v2-experimental/iteration-4 ✅
To be commented (post-Feb 28):
v2 iterations 1-3
v3 attempts (all variants)
v3-alpha breakthrough
v4 (both versions)
v5 iterations
v5 refinement concepts
Files & Versions
v0-getters.acs - Simple getter functions (Sept 2022)
v1-preset-attempts/ - Button → dropdown transition attempts (Oct 17-20, 2022)
v2-experimental/ - Overlap behavior attempts (Oct 24-26, 2022)
v3-attempts/ - Parallel experimentation (Oct 24, 2022)
v3-alpha-breakthrough/ - Router + worker success (Oct 27, 2022)
v4-consolidated/ - Scalability improvements (Dec 30, 2025)
v5-unified-worker/ - Modern unified architecture (Dec 2025 - Jan 2026)
Additional Notes
All iterations preserved for historical reference and potential future insights. Failed attempts contain valuable lessons and patterns that might spark solutions to future problems.
The progression from v0 (3 simple scripts) to v5 (sophisticated state management) represents ~6 weeks of active development spread across 2022 and 2025-2026, with significant learning about programming fundamentals, architectural patterns, and modern development workflows.