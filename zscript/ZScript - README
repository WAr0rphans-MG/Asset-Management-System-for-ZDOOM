# ZScript

*Code written January 2026 with AI assistance | Documentation created February 2025 with Claude AI assistance*

---

## Overview

ZScript was introduced in v5 (January 2026) to replace SBARINFO and add real-time menu preview functionality. Unlike ACS and DECORATE (which evolved over years), ZScript represents a single architectural leap enabled by modern GZDoom capabilities and AI-assisted development.

All three ZScript components were generated by Microsoft Copilot and Google Gemini based on architectural requirements, then tested and debugged through iteration.

---

## Why ZScript in v5?

**Problems with v1-v4 approach:**
1. **SBARINFO limitations:** Declarative syntax, nested conditionals hard to maintain
2. **Menu UX issue:** Changes don't apply until menu closes (script execution paused during menu)
3. **ArmorID overhead:** ACS script loops every tic checking armor properties

**ZScript solutions:**
1. **Modern HUD:** Programmatic drawing with full control, cleaner logic
2. **Live menu preview:** Script runs during menu interaction (Ticker override)
3. **Event handlers:** Efficient armor tracking without constant looping

---

## The Three Components

### 1. AMSOptionsMenu.zs - Real-Time Menu Preview

**File:** `AMSOptionsMenu.zs`

**Problem it solves:** 
In v0-v4, changing dropdowns in menu had no effect until menu closed. Users couldn't preview changes in real-time.

**How it works:**
```zscript
class AMSOptionsMenu : OptionMenu
{
    int lastPreset;
    
    override void Ticker()  // Runs every frame, even during menu
    {
        int preset = CVar.GetCVar("pretoggle", players[consoleplayer]).GetInt();
        
        if (preset != lastPreset || custom == 0)
        {
            CallACS("SYMWorker", 0);  // Apply changes immediately
            lastPreset = preset;
            Init(mParentMenu, mDesc);  // Refresh menu display
        }
    }
}
Key features:
Ticker override runs during menu (not paused)
Detects preset changes
Calls ACS to update CVars
Refreshes menu display to show new values
Preserves cursor position during refresh
Development:
Generated by Copilot based on requirements
Added asmtoggle handling for preset/custom mode detection
Bug discovered during documentation: cv.GetInt() used instead of as.GetInt() (copy-paste error, fixed before ship)
UX improvement: Changes now apply instantly while menu is open - can see sprite updates behind menu in real-time!
2. AMSArmorHandler.zs - Token Distribution System
File: AMSArmorHandler.zs
Problem it solves:
v1-v4 used ArmorIDSystem ACS script that looped every tic checking armor class names. This was:
Performance overhead (constant looping)
Highly repetitive (~100+ lines of duplicated checks)
Hardcoded actor names (not flexible)
How it works:
class AMSArmorHandler : StaticEventHandler
{
    override void WorldTick()  // Automatic, runs every tick
    {
        for (int i = 0; i < MAXPLAYERS; i++)
        {
            if (playeringame[i])
            {
                UpdateArmorTokens(players[i].mo);
            }
        }
    }
    
    void UpdateArmorTokens(Actor p)
    {
        // Check armor PROPERTIES, not class names
        if (max == 200 && perc ≈ 0.50)
            activeToken = "AMS_ArmorID_Blue";
        else if (max == 100 && perc ≈ 0.33 && amt >= 100)
            activeToken = "AMS_ArmorID_Green";
        // ...
        
        // Give/take tokens as needed
    }
}
Key improvements over ACS ArmorID:
Property-based detection: Checks max/percent/amount, not hardcoded class names
Array-driven tokens: Clean give/take logic
Automatic execution: StaticEventHandler runs without explicit calls
Multi-player support: Handles all players automatically
Conditional updates: Only changes inventory when needed
Floating-point tolerance:
(perc > 0.49 && perc < 0.51)  // Checks if ≈ 0.50
Uses tolerance ranges instead of exact equality because floating-point math isn't precise (0.5 might be stored as 0.500000001)
Development:
Generated by Copilot
Tested with Gemini assistance for debugging
~40 lines vs ~100+ in ACS version
3. AMSFullScreenHUD.zs - Complete HUD Replacement
File: AMSFullScreenHUD.zs
Problem it solves:
SBARINFO (v1-v4) worked but was:
Declarative syntax with nested conditionals
~300+ lines of IfCVarInt and InInventory blocks
Hard to maintain and extend
How it works:
class AMSFullScreenHUD : DoomStatusBar
{
    override void Draw(int state, double TicFrac)
    {
        if (state == HUD_Fullscreen)
        {
            // Get CVars
            int med = CVar.GetCVar("medtoggle", ...).GetInt();
            int d64 = CVar.GetCVar("putoggle", ...).GetInt();
            
            // Determine icon based on mode and value
            if (d64 == 1) {
                // DOOM 64 mode icons
            } else {
                // 1993 mode icons
            }
            
            // Draw with custom scaling/positioning
            DrawTexture(icon, position, scale: iconScale);
        }
    }
}
What it draws:
Health icon: Based on medtoggle/brztoggle + berserk status + d64 mode
Armor icon: Based on AMS armor tokens + d64 mode + botoggle
Ammo icons: Based on current weapon + d64 mode (with custom scaling)
Keys: Iterate inventory, display with d64 variants if enabled
Key features:
Programmatic drawing (full control over positioning, scaling, offsets)
Dynamic icon selection (checks multiple conditions)
Custom scaling per icon (some sprites need adjustment for visual consistency)
Fallback logic (if icon invalid, use default)
Commented-out code:
Contains old token system checks (BarmorToken, GarmorToken, etc.) showing transition from v1-v4 token names to new AMS_ArmorID_* tokens.
Development:
Generated by Copilot based on SBARINFO logic
Tested and debugged for visual consistency
Added custom scaling values through trial and error
Commented sections show evolution from old to new token system
Benefits over SBARINFO:
Object-oriented (cleaner structure)
~200 lines but WAY more functionality
Can do real-time calculations
Custom scaling/offsets per sprite
Modern GZDoom standard
Development Process
All three scripts followed similar workflow:
Requirements definition: Explained what needed to happen (real-time menu, armor tracking, HUD display)
AI generation: Copilot/Gemini generated initial code
Testing: Ran in-game, identified issues
Iteration: Reported errors, AI generated fixes
Refinement: Added specific logic (asmtoggle handling, custom scaling)
Collaboration approach:
AI provided architectural scaffolding
I provided domain knowledge (GZDoom specifics, what existed in SBARINFO)
Testing revealed edge cases
Iteration until working correctly
Time investment: Much faster than learning ZScript from scratch - requirements → working code in hours, not days
Why This Approach Worked
Standing on shoulders:
SBARINFO logic already defined what HUD needed to do
ArmorID ACS showed what armor tracking needed
Menu UX issue was clearly identified from v1-v4 experience
AI as translator:
I knew WHAT was needed (requirements)
AI knew HOW in ZScript (implementation)
Together: working solution without deep ZScript expertise
Iteration over perfection:
First versions had bugs
Testing revealed issues
AI fixed based on feedback
Resulted in working, maintainable code
Integration with v5 Architecture
ZScript works alongside ACS and DECORATE:
ACS (MEDSymbol.acs):
Preset/custom mode logic
CVar management
State tracking (LastPreset)
DECORATE:
Actor routing
Sprite display
Pickup behavior
ZScript:
Menu live preview (calls ACS during menu)
Armor token distribution (automated)
HUD rendering (reads CVars, displays icons)
Data flow:
User changes menu → ZScript menu calls ACS → ACS updates CVars → 
DECORATE reads CVars → Sprite changes → ZScript HUD reads CVars → 
Icon updates
All three languages working together in v5's unified architecture!
Code Commenting Status
To be commented (post-Feb 28):
AMSOptionsMenu.zs (with bug fix note)
AMSArmorHandler.zs
AMSFullScreenHUD.zs (with transition notes on old tokens)
Files
AMSOptionsMenu.zs - Real-time menu preview and refresh
AMSArmorHandler.zs - Automated armor token distribution
AMSFullScreenHUD.zs - Complete HUD rendering system
Additional Notes
ZScript represents a different learning approach than ACS and DECORATE:
ACS/DECORATE: Self-taught through reverse-engineering and iteration (2022)
ZScript: AI-assisted implementation based on clear requirements (2026)
Both approaches are valid. The key difference is having solid requirements (from years of working with SBARINFO/ACS) meant AI could generate working code quickly.
This demonstrates modern development workflow: understanding WHAT you need, using tools to implement HOW, then testing and refining the result.